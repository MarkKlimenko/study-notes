= MongoDB notes
:sectnums:
:toc: left
:toclevels: 5
:icons: font
:source-highlighter: coderay

== Introduction

MongoDB is a powerful, flexible, and scalable general-purpose database.
It combines the ability to scale out with features such as secondary indexes, range queries, sorting, aggregations, and geospatial indexes.

MongoDB is a document-oriented database, not a relational one.

A document-oriented database replaces the concept of a “row” with a more flexible model, the “document.” By allowing embedded documents and arrays, the documentoriented approach makes it possible to represent complex hierarchical relationships with a single record.

There are also no predefined schemas: a document’s keys and values are not of fixed types or sizes.
Without a fixed schema, adding or removing fields as needed becomes easier.

=== Designed to Scale

Scaling a database comes down to the choice between scaling up (getting a bigger machine) or scaling out (partitioning data across more machines).

MongoDB was designed to scale out.
The document-oriented data model makes it easier to split data across multiple servers.
MongoDB automatically takes care of balancing data and load across a cluster, redistributing documents automatically and routing reads and writes to the correct machines

image::images/image-2024-05-15-18-10-34-201.png[width=500]

The topology of a MongoDB cluster, or whether there is in fact a cluster rather than a single node at the other end of a database connection, is transparent to the application.
This allows developers to focus on programming the application, not scaling it.

=== Features

** *Indexing*
MongoDB supports generic secondary indexes and provides unique, compound, geospatial, and full-text indexing capabilities as well.
Secondary indexes on hierarchical structures such as nested documents and arrays are also supported and enable developers to take full advantage of the ability to model in ways that best suit their applications.
** *Aggregation*
MongoDB provides an aggregation framework based on the concept of data processing pipelines.
Aggregation pipelines allow you to build complex analytics engines by processing data through a series of relatively simple stages on the server side, taking full advantage of database optimizations.
** *Special collection and index types*
MongoDB supports time-to-live (TTL) collections for data that should expire at a certain time, such as sessions and fixed-size (capped) collections, for holding recent data, such as logs.
MongoDB also supports partial indexes limited to only those documents matching a criteria filter in order to increase efficiency and reduce the amount of storage space required.
** *File storage*
MongoDB supports an easy-to-use protocol for storing large files and file metadata.
** *Limited Joins*
MongoDB supports joins in a very limited way through use of the $lookup aggregation operator

== Getting Started

* A *document* is the basic unit of data for MongoDB and is roughly equivalent to a row in a relational database management system (but much more expressive).
* Similarly, a *collection* can be thought of as a table with a dynamic schema.
* A single instance of MongoDB can host multiple independent *databases*, each of which contains its own collections.
* Every document has a special *key*, "_id", that is unique within a collection.
* MongoDB is distributed with a simple but powerful tool called the *mongo shell*.
The mongo shell provides built-in support for administering MongoDB instances and manipulating data using the MongoDB query language.
* It is also a fully functional *JavaScript interpreter* that enables users to create and load their own scripts for a variety of purposes.

=== Documents

Document: an ordered set of keys with associated values.

[source,json]
----
{"greeting" : "Hello, world!", "views" : 3}
----

=== Collections

A collection is a group of documents.
If a document is the MongoDB analog of a row in a relational database, then a collection can be thought of as the analog to a table.

==== Dynamic Schemas

Collections have dynamic schemas.
This means that the documents within a single collection can have any number of different “shapes.” For example, both of the following documents could be stored in a single collection:

[source,json]
----
{"greeting" : "Hello, world!", "views": 3}
----

[source,json]
----
{"signoff": "Good night, and good luck"}
----

==== Subcollections

One convention for organizing collections is to use namespaced subcollections separated by the . character.
For example, an application containing a blog might have a collection named blog.posts and a separate collection named blog.authors.
This is for organizational purposes only—there is no relationship between the blog collection (it doesn’t even have to exist) and its “children.”

=== Databases

MongoDB groups collections into databases.
A single instance of MongoDB can host several databases, each grouping together zero or more collections.
A good rule of thumb is to store all data for a single application in the same database.

Historically, prior to the use of the WiredTiger storage engine, database names became files on your filesystem.
It is no longer the case.
This explains why many of the previous restrictions exist in the first place.

There are also some reserved database names, which you can access but which have special semantics.
These are as follows:

** *admin*
The admin database plays a role in authentication and authorization.
In addition, access to this database is required for some administrative operations.
See Chapter 19 for more information about the admin database.
** *local*
This database stores data specific to a single server.
In replica sets, local stores data used in the replication process.
The local database itself is never replicated.
(See Chapter 10 for more information about replication and the local database.)
** *config*
Sharded MongoDB clusters (see Chapter 14) use the config database to store information about each shard.

IMPORTANT: By concatenating a database name with a collection in that database you can get a fully qualified collection name, which is called a namespace.
For instance, if you are using the blog.posts collection in the cms database, the namespace of that collection would be cms.blog.posts.
Namespaces are limited to 120 bytes in length and, in practice, should be fewer than 100 bytes long.

== Getting and Starting MongoDB

=== Start server

[source,shell]
----
docker run --name mongo-lessons \
-p 27017:27017 \
--platform linux/arm64/v8 \
mongo:7.0.9

docker start mongo-lessons
----

=== Execute commands

[source,shell]
----
docker exec -it mongo-lessons mongosh
----

=== JavaScript interpreter

[source,shell]
----
> x = 200;
200
> x / 5;
40

> Math.sin(Math.PI / 2);
1
> new Date("20109/1/1");
ISODate("2019-01-01T05:00:00Z")
> "Hello, World!".replace("World", "MongoDB");
Hello, MongoDB!

> function factorial (n) {
... if (n <= 1) return 1;
... return n * factorial(n - 1);
... }
> factorial(5);
120
----

== Basic Commands

To see the database to which db is currently assigned

[source,shell]
----
db
----

Select which database to use

[source,shell]
----
use video
----

=== Create (Insert)

[source,js]
----
// insertOne will add an "_id" key to the document (if you do not supply one) and store the document in MongoDB
movie = {"title" : "Star Wars: Episode IV - A New Hope",
  "director" : "George Lucas",
  "year" : 1977}

db.movies.insertOne(movie)

// or
db.movies.insertOne({"title" : "Stand by Me"})

// insertMany
db.movies.drop()
db.movies.insertMany([{"title" : "Ghostbusters"},
{"title" : "E.T."},
{"title" : "Blade Runner"}])
db.movies.find()
----

If you are just importing raw data (e.g., from a data feed or MySQL), there are command-line tools like mongoimport that can be used instead of a batch insert.

==== Insert Validation

MongoDB does minimal checks on data being inserted: it checks the document’s basic structure and adds an "_id" field if one does not exist.
One of the basic structure checks is size: all documents must be smaller than 16 MB.
This is a somewhat arbitrary limit (and may be raised in the future); it is mostly intended to prevent bad schema design and ensure consistent performance.

IMPORTANT: To give you an idea of how much data 16 MB is, the entire text of War and Peace is just 3.14 MB.

=== Read (findOne)

Will be described later

[source,js]
----
db.movies.findOne()
----

=== Update

updateOne and update Many each take a filter document as their first parameter and a modifier document, which describes changes to make, as the second parameter.
replaceOne also takes a filter as the first parameter, but as the second parameter replaceOne expects a document with which it will replace the document matching the filter.

==== Replace

[source,js]
----
var joe = db.users.findOne({"name" : "joe"});
joe.relationships = {"friends" : joe.friends, "enemies" : joe.enemies};
joe.username = joe.name;

delete joe.friends;
delete joe.enemies;
delete joe.name;

db.users.replaceOne({"name" : "joe"}, joe);
----

==== Update operators

*$inc*

[source,js]
----
/*
{
    "_id" : ObjectId("4b253b067525f35f94b60a31"),
    "url" : "www.example.com",
    "pageviews" : 52
}
*/

db.analytics.updateOne({"url" : "www.example.com"},
{"$inc" : {"pageviews" : 1}})

db.analytics.findOne()
/*
{
    "_id" : ObjectId("4b253b067525f35f94b60a31"),
    "url" : "www.example.com",
    "pageviews" : 53
}
*/
----

*$set $unset*

Sets the value of a field.
If the field does not yet exist, it will be created.
This can be handy for updating schemas or adding user-defined keys.

[source,js]
----
db.movies.updateOne({title : "Star Wars: Episode IV - A New Hope"}, {$set : {reviews: []}})

db.users.updateOne(
    {"_id" : ObjectId("4b253b067525f35f94b60a31")},
    {"$set" : {"favorite book" : "War and Peace"}}
)

// change data type
db.users.updateOne(
    {"name" : "joe"},
    {"$set" : {"favorite book" : ["Cat's Cradle", "Foundation Trilogy", "Ender's Game"]}}
)

// remove field $unset
db.users.updateOne(
    {"name" : "joe"},
    {"$unset" : {"favorite book" : 1}}
)

// You can also use "$set" to reach in and change embedded documents
db.blog.posts.findOne()
/*{
    "_id" : ObjectId("4b253b067525f35f94b60a31"),
    "title" : "A Blog Post",
    "content" : "...",
    "author" : {
        "name" : "joe",
        "email" : "joe@example.com"
    }
}*/
db.blog.posts.updateOne(
    {"author.name" : "joe"},
    {"$set" : {"author.name" : "joe schmoe"}}
)
db.blog.posts.findOne()
/*{
    "_id" : ObjectId("4b253b067525f35f94b60a31"),
    "title" : "A Blog Post",
    "content" : "...",
    "author" : {
        "name" : "joe schmoe",
        "email" : "joe@example.com"
    }
}*/
----

==== Array operators

*$push*

[source,js]
----
/*
{
    "_id" : ObjectId("4b2d75476cc613d5ee930164"),
    "title" : "A blog post",
    "content" : "..."
}
*/

db.blog.posts.updateOne(
    {"title" : "A blog post"},
    {"$push" : {"comments" :
        {"name" : "joe", "email" : "joe@example.com", "content" : "nice post."}
    }}
)

/*
{
    "_id" : ObjectId("4b2d75476cc613d5ee930164"),
    "title" : "A blog post",
    "content" : "...",
    "comments" : [
        {
            "name" : "joe",
            "email" : "joe@example.com",
            "content" : "nice post."
        }
    ]
}
*/

// Now, if we want to add another comment, we can simply use "$push" again
----

*$each*

[source,js]
----
// You can push multiple values in one operation using the "$each" modifier for "$push"

db.stock.ticker.updateOne({"_id" : "GOOG"},
    {"$push" : {"hourly" : {"$each" : [562.776, 562.790, 559.123]}}})

// This would push three new elements onto the array.
----

*$slice*

If you only want the array to grow to a certain length, you can use the "$slice" modifier with "$push" to prevent an array from growing beyond a certain size, effectively making a “top N” list of items:

[source,js]
----
// This example limits the array to the last 10 elements pushed.
// If the array is smaller than 10 elements (after the push), all elements will be kept. If
// the array is larger than 10 elements, only the last 10 elements will be kept.
db.movies.updateOne({"genre" : "horror"},
    {"$push" : {"top10" : {"$each" : ["Nightmare on Elm Street", "Saw"],
    "$slice" : -10}}})
----

*$sort*

Finally, you can apply the "$sort" modifier to "$push" operations before trimming

[source,js]
----
db.movies.updateOne({"genre" : "horror"},
    {"$push" : {"top10" : {"$each" : [{"name" : "Nightmare on Elm Street",
    "rating" : 6.6},
    {"name" : "Saw", "rating" : 4.3}],
    "$slice" : -10,
    "$sort" : {"rating" : -1}}}})
----

This will sort all of the objects in the array by their "rating" field and then keep the first 10.
Note that you must include "$each"; you cannot just "$slice" or "$sort" an array with "$push"

*$ne*

You might want to treat an array as a set, only adding values if they are not present.

[source,js]
----
db.papers.updateOne({"authors cited" : {"$ne" : "Richie"}},
    {$push : {"authors cited" : "Richie"}})

// This can also be done with "$addToSet", which is useful for cases where "$ne" won’t work or where "$addToSet" describes what is happening better.
db.users.updateOne({"_id" : ObjectId("4b2d75476cc613d5ee930164")},
    {"$addToSet" : {"emails" : "joe@gmail.com"}})
----

*$addToSet*

You can also use "$addToSet" in conjunction with "$each" to add multiple unique values, which cannot be done with the "$ne"/"$push" combination.

[source,js]
----
db.users.updateOne({"_id" : ObjectId("4b2d75476cc613d5ee930164")},
    {"$addToSet" : {"emails" : {"$each" :
    ["joe@php.net", "joe@example.com", "joe@python.org"]}}})
----

*$pop*

If you want to treat the array like a queue or a stack, you can use "$pop", which can remove elements from either end. {"$pop" : {"key" : 1}} removes an element from the end of the array. {"$pop" : {"key" : -1}} removes it from the beginning.

*$pull*

Sometimes an element should be removed based on specific criteria, rather than its position in the array. "$pull" is used to remove elements of an array that match the given criteria.

[source,js]
----
db.lists.insertOne({"todo" : ["dishes", "laundry", "dry cleaning"]})

db.lists.updateOne({}, {"$pull" : {"todo" : "laundry"}})

db.lists.findOne()
// {
//     "_id" : ObjectId("4b2d75476cc613d5ee930164"),
//     "todo" : ["dishes", "dry cleaning"]
// }
----

Pulling removes all matching documents, not just a single match.
If you have an array that looks like [1, 1, 2, 1] and pull 1, you’ll end up with a single-element array, [2].

*Positional array modifications*

Arrays use 0-based indexing

[source,js]
----
/*{
  "_id": ObjectId(
  "4b329a216cc613d5ee930192"
  ),
  "content": "...",
  "comments": [
    {
      "comment": "good post",
      "author": "John",
      "votes": 0
    },
    {
      "comment": "i thought it was too short",
      "author": "Claire",
      "votes": 3
    },
    {
      "comment": "free watches",
      "author": "Alice",
      "votes": -5
    },
    {
      "comment": "vacation getaways",
      "author": "Lynn",
      "votes": -7
    }
  ]
}*/

db.blog.updateOne({"post" : post_id},
    {"$inc" : {"comments.0.votes" : 1}})

db.blog.updateOne({"comments.author" : "John"},
... {"$set" : {"comments.$.author" : "Jim"}})
----

==== Upserts

An upsert is a special type of update.
If no document is found that matches the filter, a new document will be created by combining the criteria and updated documents.
If a matching document is found, it will be updated normally.
Upserts can be handy because they can eliminate the need to “seed” your collection: you can often have the same code create and update documents.

[source,js]
----
db.analytics.updateOne({"url" : "/blog"}, {"$inc" : {"pageviews" : 1}},
    {"upsert" : true})

// The new document is created by using the criteria document as a base and applying any modifier documents to it.

db.users.updateOne({"rep" : 25}, {"$inc" : {"rep" : 3}}, {"upsert" : true})
db.users.findOne({"_id" : ObjectId("5727b2a7223502483c7f3acd")} )
// { "_id" : ObjectId("5727b2a7223502483c7f3acd"), "rep" : 28 }
----

==== The save shell helper

save is a shell function that lets you insert a document if it doesn’t exist and update it if it does.
It takes one argument: a document.
If the document contains an "_id" key, save will do an upsert.
Otherwise, it will do an insert. save is really just a convenience function so that programmers can quickly modify documents in the shell:

[source,js]
----
var x = db.testcol.findOne()
x.num = 42
db.testcol.save(x)
----

==== Updating Multiple Documents

So far in this chapter we have used updateOne to illustrate update operations.
updateOne updates only the first document found that matches the filter criteria.
If there are more matching documents, they will remain unchanged.
To modify all of the documents matching a filter, use updateMany. updateMany follows the same semantics as updateOne and takes the same parameters.
The key difference is in the number of documents that might be changed.

[source,js]
----
// Suppose, for example, we want to give a gift to every user who has a birthday on a certain day

db.users.insertMany([
    {birthday: "10/13/1978"},
    {birthday: "10/13/1978"},
    {birthday: "10/13/1978"}])
/*{
"acknowledged" : true,
"insertedIds" : [
    ObjectId("5727d6fc6855a935cb57a65b"),
    ObjectId("5727d6fc6855a935cb57a65c"),
    ObjectId("5727d6fc6855a935cb57a65d")
    ]
}*/

> db.users.updateMany({"birthday" : "10/13/1978"},
    {"$set" : {"gift" : "Happy Birthday!"}})
// { "acknowledged" : true, "matchedCount" : 3, "modifiedCount" : 3 }
----

==== Returning Updated Documents

findOneAndDelete, findOneAndReplace, and findOneAndUpdate

[source,js]
----
db.processes.findOneAndUpdate({"status" : "READY"},
    {"$set" : {"status" : "RUNNING"}},
    {"sort" : {"priority" : -1}})

/*{
"_id" : ObjectId("4b3e7a18005cab32be6291f7"),
"priority" : 1,
"status" : "READY"
}*/
----

Notice that the status is still "READY" in the returned document because the findOneAndUpdate method defaults to returning the state of the document before it was modified.
It will return the updated document if we set the "returnNewDocu ment" field in the options document to true.

=== Delete

[source,js]
----
db.movies.deleteOne({title : "Star Wars: Episode IV - A New Hope"})

// or
db.movies.deleteOne({"_id" : 4})

// or
db.movies.deleteMany({"year" : 1984})

// or
db.movies.drop()
----

Use deleteMany to delete all documents matching a filter

== Data Types

=== Common data types

==== Null

The null type can be used to represent both a null value and a nonexistent field:

{"x" : null}

==== Boolean

There is a boolean type, which can be used for the values true and false:

{"x" : true}

==== Number

The shell defaults to using 64-bit floating-point numbers.
Thus, these numbers both look “normal” in the shell:

{"x" : 3.14}
{"x" : 3}

For integers, use the NumberInt or NumberLong classes, which represent 4-byte or 8-byte signed integers, respectively.

{"x" : NumberInt("3")}
{"x" : NumberLong("3")}

==== String

Any string of UTF-8 characters can be represented using the string type:

{"x" : "foobar"}

==== Date

MongoDB stores dates as 64-bit integers representing milliseconds since the Unix epoch (January 1, 1970).
The time zone is not stored:

{"x" : new Date()}

==== Regular expression

Queries can use regular expressions using JavaScript’s regular expression syntax:

{"x" : /foobar/i}

==== Array

Sets or lists of values can be represented as arrays:

{"x" : ["a", "b", "c"]}

==== Embedded document

Documents can contain entire documents embedded as values in a parent document:

{"x" : {"foo" : "bar"}}

==== Object ID

An object ID is a 12-byte ID for documents:

{"x" : ObjectId()}

See the section “_id and ObjectIds” on page 20 for details.

==== Binary data

Binary data is a string of arbitrary bytes.
It cannot be manipulated from the shell.
Binary data is the only way to save non-UTF-8 strings to the database.

==== Code

MongoDB also makes it possible to store arbitrary JavaScript in queries and documents:

{"x" : function() { /* ... */ }}

== Querying

** *findOne()* returns a document, or nil/null/whatever-it-is-called
** *find()* returns a cursor, which can be empty.
But the object returned is always defined.

=== Introduction to find

The find method is used to perform queries in MongoDB.
Querying returns a subset of documents in a collection, from no documents at all to the entire collection.
Which documents get returned is determined by the first argument to find, which is a document specifying the query criteria.

An empty query document (i.e., {}) matches everything in the collection.
If find isn’t given a query document, it defaults to {}

[source,js]
----
db.c.find()
----

Add search parameters

[source,js]
----
db.users.find({"age" : 27})
db.users.find({"username" : "joe"})
db.users.find({"username" : "joe", "age" : 27})
----

=== Specifying Which Keys to Return

[source,js]
----
// Include
db.users.find({}, {"username" : 1, "email" : 1})
/*{
    "_id" : ObjectId("4ba0f0dfd22aa494fd523620"),
    "username" : "joe",
    "email" : "joe@example.com"
}*/

// Exclude
db.users.find({}, {"fatal_weakness" : 0})
db.users.find({}, {"username" : 1, "_id" : 0})
----

=== Query Criteria

==== Query Conditionals

"$lt", "$lte", "$gt", and "$gte" are all comparison operators, corresponding to <, <=, >, and >=, respectively.

[source,js]
----
// look for users who are between the ages of 18 and 30
db.users.find({"age" : {"$gte" : 18, "$lte" : 30}})

// find people who registered before January 1, 2007
start = new Date("01/01/2007")
db.users.find({"registered" : {"$lt" : start}})

// to find all users who do not have the username “joe”
db.users.find({"username" : {"$ne" : "joe"}})
----

==== OR Queries

[source,js]
----
// "$in" can be used to query for a variety of values for a single key
db.raffle.find({"ticket_no" : {"$in" : [725, 542, 390]}})

// "$in" is very flexible and allows you to specify criteria of different types as well as values
db.users.find({"user_id" : {"$in" : [12345, "joe"]}})

// The opposite of "$in" is "$nin", which returns documents that don’t match any of the criteria in the array.
db.raffle.find({"ticket_no" : {"$nin" : [725, 542, 390]}})

// "$or" takes an array of possible criteria
db.raffle.find({"$or" : [{"ticket_no" : 725}, {"winner" : true}]})

// "$or" can contain other conditionals
db.raffle.find({"$or" : [{"ticket_no" : {"$in" : [725, 542, 390]}},
    {"winner" : true}]})
----

==== $not

"$not" is a metaconditional: it can be applied on top of any other criteria

[source,js]
----
// query returns users with "id_num"s of 1, 6, 11, 16, and so on
db.users.find({"id_num" : {"$mod" : [5, 1]}})

// To return users with "id_num"s of 2, 3, 4, 5, 7, 8, 9, 10, 12, etc., we can use "$not"
db.users.find({"id_num" : {"$not" : {"$mod" : [5, 1]}}})
----

=== Type-Specific Queries








