= Java Memory Model and Memory Management
:sectnums:
:toc: left
:toclevels: 5
:icons: font
:source-highlighter: coderay


== Memory Model

The Java Memory Model (JMM) defines the allowable behavior of multithreaded programs.
It places execution-time constraints on the relationship between threads and main memory in order to achieve consistent and reliable Java applications.

The Java memory model used internally in the JVM divides memory between thread stacks and the heap.

image::images/image-2024-05-21-20-52-00-988.png[width=500]

Each thread running in the Java virtual machine has its own thread stack.

*The thread stack contains:*

* information about what methods the thread has called to reach the current point of execution.
* all local variables for each method being executed.
* all local variables of primitive types ( boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads.
One thread may pass a copy of a primitive variable to another thread, but it cannot share the primitive local variable itself.

*The heap contains:*

* all objects created in your Java application, regardless of what thread created the object.
This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc.).
It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap.

image::images/image-2024-05-22-10-15-45-833.png[width=500]

=== Java Heap Space vs Stack Memory

TODO: https://www.digitalocean.com/community/tutorials/java-heap-space-vs-stack-memory

=== Hardware Memory Architecture

image::images/image-2024-05-22-10-42-39-951.png[width=500]

Each CPU contains:

* a set of registers which are essentially in-CPU memory.
* a CPU cache memory layer.

A computer contains:

* a main memory area (RAM).

The hardware memory architecture does not distinguish between thread stacks and heap.

image::images/image-2024-05-22-10-46-53-155.png[width=500]

*The two main problems are:*

* Visibility of thread updates (writes) to shared variables.
* Race conditions when reading, checking and writing shared variables.

=== Problems

==== Visibility of Shared Objects

If two or more threads are sharing an object, without the proper use of either volatile declarations or synchronization, updates to the shared object made by one thread may not be visible to other threads.

A thread running on CPU one then reads the shared object into its CPU cache.
There it makes a change to the shared object.
As long as the CPU cache has not been flushed back to main memory, the changed version of the shared object is not visible to threads running on other CPUs.

To solve this problem you can use Java's `volatile` keyword.
The volatile keyword can make sure that a given variable is read directly from main memory, and always written back to main memory when updated.

==== Race Conditions

If two or more threads share an object, and more than one thread updates variables in that shared object, race conditions may occur.

To solve this problem you can use a Java `synchronized` block.
A synchronized block guarantees that only one thread can enter a given critical section of the code at any given time.

=== Volatile

`volatile` says for a programmer that the value always will be up to date.
The problem is that the value can be saved on different types of hardware memory.
For example it can be CPU registers, CPU cache, RAM.
СPU registers and CPU cache belong to CPU and can not share a data unlike of RAM which is on the rescue in multithreading environment

image::images/image-2024-05-20-21-03-12-208.png[width=500]

`volatile` keyword says that a variable will be read and written from/to RAM memory directly.

IMPORTANT: `volatile` keyword does not cure a race condition situation.
To solve it use `synchronized` keyword.

*As a result it is safety only when one thread writes and others just read the `volatile` value.*

=== Happens Before

*Ordering* - compiler is able to change an ordering of operations/instructions of source code to make some optimisations.

Two actions can be ordered by a happens-before relationship.
If one action happens-before another, then the first is visible to and ordered before the second.

*A write to a volatile field happens-before every subsequent read of that field.*

== Heap Inside

image::images/image-2024-05-20-21-36-37-769.png[width=500]

JVM memory is divided into separate parts.
At broad level, JVM Heap memory is physically divided into two parts - *Young Generation* and *Old Generation*.

=== Young Generation

The young generation is the place where all the new objects are created.
When the young generation is filled, garbage collection is performed.
This garbage collection is called *Minor GC*.

Young Generation is divided into three parts - *Eden Memory* and two *Survivor Memory* spaces.

* Most of the newly created objects are located in the Eden memory space.
* When Eden space is filled with objects, Minor GC is performed and all the survivor objects are moved to one of the survivor spaces.
* Minor GC also checks the survivor objects and move them to the other survivor space.
So at a time, one of the survivor space is always empty.
* Objects that are survived after many cycles of GC, are moved to the Old generation memory space.
Usually, it’s done by setting a threshold for the age of the young generation objects before they become eligible to promote to Old generation.

=== Old Generation

Old Generation memory contains the objects that are long-lived and survived after many rounds of Minor GC.
Usually, garbage collection is performed in Old Generation memory when it’s full.
Old Generation Garbage Collection is called *Major GC* and usually takes a longer time.

*Major GC can involve young and old generation*
TODO: check it

=== Stop the World Event

All the Garbage Collections are “Stop the World” events because all application threads are stopped until the operation completes.
Since Young generation keeps short-lived objects, Minor GC is very fast and the application doesn’t get affected by this.
However, Major GC takes a long time because it checks all the live objects.

=== Permanent Generation (Metaspace)

Permanent Generation or “Perm Gen” contains the application metadata required by the JVM to describe the classes and methods used in the application.
Note that Perm Gen is not part of Java Heap memory.
Perm Gen is populated by JVM at runtime based on the classes used by the application.
Perm Gen also contains Java SE library classes and methods.
Perm Gen objects are garbage collected in a full garbage collection.

*For java 8 it is Metaspace*

Metaspace is autoextending
TODO:

=== References

WeakReference SoftReference
TODO:

== Memory Management

=== Java Heap Memory Switches

* **-Xms**    For setting the initial heap size when JVM starts
* **-Xmx**    For setting the maximum heap size.
* **-Xmn**    For setting the size of the Young Generation, rest of the space goes for Old Generation.
* **-XX:PermGen**    For setting the initial size of the Permanent Generation memory
* **-XX:MaxPermGen**    For setting the maximum size of Perm Gen
* **-XX:SurvivorRatio**    For providing ratio of Eden space and Survivor Space, for example if Young Generation size is 10m and VM switch is -XX:SurvivorRatio=2 then 5m will be reserved for Eden Space and 2.5m each for both the Survivor spaces.
The default value is 8.
* **-XX:NewRatio**    For providing ratio of old/new generation sizes.
The default value is 2.

=== Java Garbage Collection

Garbage Collector is the program running in the background that looks into all the objects in the memory and find out objects that are not referenced by any part of the program.
All these unreferenced objects are deleted and space is reclaimed for allocation to other objects.
One of the basic ways of garbage collection involves three steps:

* **Marking:** This is the first step where garbage collector identifies which objects are in use and which ones are not in use.
* **Normal Deletion:** Garbage Collector removes the unused objects and reclaim the free space to be allocated to other objects.
* **Deletion with Compacting:** For better performance, after deleting unused objects, all the survived objects can be moved to be together.
This will increase the performance of allocation of memory to newer objects.

There are two problems with a simple mark and delete approach.

* First one is that it’s not efficient because most of the newly created objects will become unused
* Secondly objects that are in-use for multiple garbage collection cycle are most likely to be in-use for future cycles too.

=== Java Garbage Collection Types

There are five types of garbage collectors that we can use in our applications.
We just need to use the JVM switch to enable the garbage collection strategy for the application.

TODO:

** *Serial GC (-XX:+UseSerialGC):*
Serial GC uses the simple mark-sweep-compact approach for young and old generations garbage collection i.e Minor and Major GC.
Serial GC is useful in client machines such as our simple stand-alone applications and machines with smaller CPU.
It is good for small applications with low memory footprint.
** *Parallel GC (-XX:+UseParallelGC):*
Parallel GC is same as Serial GC except that is spawns N threads for young generation garbage collection where N is the number of CPU cores in the system.
We can control the number of threads using -XX:ParallelGCThreads=n JVM option.
Parallel Garbage Collector is also called throughput collector because it uses multiple CPUs to speed up the GC performance.
Parallel GC uses a single thread for Old Generation garbage collection.
** *Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC):*
CMS Collector is also referred as concurrent low pause collector.
It does the garbage collection for the Old generation.
CMS collector tries to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads.
CMS collector on the young generation uses the same algorithm as that of the parallel collector.
This garbage collector is suitable for responsive applications where we can’t afford longer pause times.
We can limit the number of threads in CMS collector using -XX:ParallelCMSThreads=n JVM option.
** *G1 Garbage Collector (-XX:+UseG1GC):*
The Garbage First or G1 garbage collector is available from Java 7 and its long term goal is to replace the CMS collector.
The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector.
Garbage First Collector doesn’t work like other collectors and there is no concept of Young and Old generation space.
It divides the heap space into multiple equal-sized heap regions.
When a garbage collection is invoked, it first collects the region with lesser live data, hence “Garbage First”.
You can find more details about it at Garbage-First Collector Oracle Documentation.
** *Epsilon GC:*
The Garbage is not needed.
** *ZGC:*
TODO:
** *Shenandoah GC:*
TODO:

== Interview questions

=== When are static variables loaded in memory ?

They are loaded at runtime when the respective Class is loaded.

=== What is a String Pool ?

String pool (String intern pool) is a special storage area in Java heap.
When a string is created and if the string already exists in the pool, the reference of the existing string will be returned, instead of creating a new object and returning its reference.

=== How many objects are created with this code ?

String s =new String("abc");

Two objects will be created here.
One object creates memory in heap with new operator and second in stack constant pool with "abc".

=== Which are the different segments of memory ?

1. Stack Segment - contains local variables and Reference variables(variables that hold the address of an object in the heap)

2. Heap Segment - contains all created objects in runtime, objects only plus their object attributes (instance variables)

3. Code Segment - The segment where the actual compiled Java bytecodes resides when loaded

=== Which memory segment loads the java code ?

Code segment.

=== Does garbage collection guarantee that a program will not run out of memory?

Garbage collection does not guarantee that a program will not run out of memory.
It is possible for programs to use up memory resources faster than they are garbage collected.
It is also possible for programs to create objects that are not subject to garbage collection

=== Describe what happens when an object is created in Java ?

1. Memory is allocated from heap to hold all instance variables and implementation-specific data of the object and its superclasses.
Implemenation-specific data includes pointers to class and method data.

2. The instance variables of the objects are initialized to their default values.

3. The constructor for the most derived class is invoked.
The first thing a constructor does is call the constructor for its superclasses.
This process continues until the constructor for java.lang.Object is called, as java.lang.Object is the base class for all objects in java.

4. Before the body of the constructor is executed, all instance variable initializers and initialization blocks are executed.
Then the body of the constructor is executed.
Thus, the constructor for the base class completes first and constructor for the most derived class completes last.

=== Describe, in general, how java's garbage collector works ?

The Java runtime environment deletes objects when it determines that they are no longer being used.
This process is known as garbage collection.
The Java runtime environment supports a garbage collector that periodically frees the memory used by objects that are no longer needed.
The Java garbage collector scans Java's dynamic memory areas for objects, marking those that are referenced.
After all possible paths to objects are investigated, those objects that are not marked (i.e. are not referenced) are known to be garbage and are collected.

=== Can I import same package/class twice?

Will the JVM load the package twice at runtime?

One can import the same package or same class multiple times.
Neither compiler nor JVM complains wil complain about it.
And the JVM will internally load the class only once no matter how many times you import the same class.

=== Different types of memory used by JVM ?

Class (???), Heap , Stack , Register , Native Method Stack.

=== What is a class loader ?

What are the different class loaders used by JVM ?

Part of JVM which is used to load classes and interfaces.

Bootstrap , Extension and System are the class loaders used by JVM.

=== Explain java.lang.OutOfMemoryError ?

This Error is thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector.

=== Is JVM, a compiler or interpretor ?

It's an interpretor.

=== Difference between loadClass and Class.forName ?

loadClass only loads the class but doesn't initialize the object whereas Class.forName initialize the object after loading it.

=== Should we override finalize method ?

Finalize is used by Java for Garbage collection.
It should not be done as we should leave the Garbage Collection to Java itself.

=== Which kind of memory is used for storing object member variables and function local variables ?

Local variables are stored in stack whereas object variables are stored in heap.

=== Why do member variables have default values whereas local variables don't have any default value ?

Member variable are loaded into heap, so they are initialized with default values when an instance of a class is created.
In case of local variables, they are stored in stack until they are being used.

=== Why Java don't use pointers ?

Pointers are vulnerable and slight carelessness in their use may result in memory problems and hence Java intrinsically manage their use.

=== What are various types of Class loaders used by JVM ?

Bootstrap - Loads JDK internal classes, java.* packages.

Extensions - Loads jar files from JDK extensions directory - usually lib/ext directory of the JRE

System - Loads classes from system classpath.

=== How are classes loaded by JVM ?

Class loaders are hierarchical.
The very first class is specially loaded with the help of static main() method declared in your class.
All the subsequently loaded classes are loaded by the classes, which are already loaded and running.

=== Difference between static vs. dynamic class loading?

static loading - Classes are statically loaded with Java’s “new” operator.

dynamic class loading - Dynamic loading is a technique for programmatically invoking the functions of a class loader at run time.

Class.forName (Test className);

=== What are strong, soft, weak and phantom references in Java ?

Garbage Collector won’t remove a strong reference.

A soft reference will only get removed if memory is low.

A weak reference will get removed on the next garbage collection cycle.

A phantom reference will be finalized but the memory will not be reclaimed.
Can be useful when you want to be notified that an object is about to be collected.

=== Name few tools for probing Java Memory Leaks ?

JProbe, OptimizeIt

=== Which memory areas does instance and static variables use ?

heap

=== What is PermGen or Permanent Generation ?

The memory pool containing all the reflective data of the java virtual machine itself, such as class and method objects.
With Java VMs that use class data sharing, this generation is divided into read-only and read-write areas.
The Permanent generation contains metadata required by the JVM to describe the classes and methods used in the application.
The permanent generation is populated by the JVM at runtime based on classes in use by the application.
In addition, Java SE library classes and methods may be stored here.

=== What is metaspace ?

The Permanent Generation (PermGen) space has completely been removed and is kind of replaced by a new space called Metaspace.
The consequences of the PermGen removal is that obviously the PermSize and MaxPermSize JVM arguments are ignored and you will never get a java.lang.OutOfMemoryError: PermGen error.

=== What are the disadvantages of using arrays ?

Arrays are of fixed size and have to reserve memory prior to use.
Hence, if we don't know size in advance arrays are not recommended to use.

Arrays can store only homogeneous elements.

Arrays store its values in contentious memory location.
Not suitable if the content is too large and needs to be distributed in memory.

There is no underlying data structure for arrays and no ready made method support for arrays, for every requriment we need to code explicitly

=== Can we call the garbage collector explicitly ?

Yes, We can call garbage collector of JVM to delete any unused variables and unreferenced objects from memory using gc( ) method.
This gc( ) method appears in both Runtime and System classes of java.lang package.

=== What are different ways to create String Object?

Explain.

String str = new String("abc"); String str1 = "abc";

When we create a String using double quotes, JVM looks in the String pool to find if any other String is stored with same value.
If found, it just returns the reference to that String object else it creates a new String object with given value and stores it in the String pool.

When we use new operator, JVM creates the String object but don’t store it into the String Pool.
We can use intern() method to store the String object into String pool or return the reference if there is already a String with equal value present in the pool.

=== How substring() method of String class create memory leaks?

substring method would build a new String object keeping a reference to the whole char array, to avoid copying it.
Hence you can inadvertently keep a reference to a very big character array with just a one character string.

=== How Java provide high Performance ?

Java uses Just-In-Time compiler to enable high performance.
Just-In-Time compiler is a program that turns Java bytecode into instructions that can be sent directly to the processor.

=== Why is Java considered Portable Language ?

Java is a portable-language because without any modification we can use Java byte-code in any platform(which supports Java).
So this byte-code is portable and we can use in any other major platforms.

=== How to find if JVM is 32 or 64 bit from Java program. ?

You can find JVM - 32 bit or 64 bit by using System.getProperty() from Java program.
